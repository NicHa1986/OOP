# Implementation and Instructions

This application captures the idea of a local doctors' surgery that asks to organize appointment and prescription requests by patients. The developed system/code can be run in using jupyter notebook and then running the corresponding file **surgery.ipynb** and it uses an object-oriented design. The aim of object-oriented programming is to create and use your own data structures. This leads to much more consistency in gathering data and it is in the design here specifically used for the two requests by patients:

. Request for an appointment (adding or cancelling)
AND/OR
. Request for a repetitive prescription

Starting the program, the app always listens to the user (= never ending while loop) and asks what the reason of his/her call is, an appointment or a prescription request. Given one of these two requests from patients, the system then makes the differentiation between a receptionist and a doctor. The former can handle appointment requests whereas the latter can handle prescription requests. 

Beginning with appointments, the appointment class itself needs a patient instance and a health professional (= doctor or nurse) instance to find the next suitable appointment that fits for both, patient and health professional. Only when an available appointment is found, the appointment schedule (= a list of appointments) will be updated and the receptionist gives the information to the patient. On the other side, if patients want to cancel an existing appointment, which will also be handled by the receptionist, the receptionist registers the information from the patient about the appointment and directly sends the cancellation request (without verifying whether the appointment exists). It is the appointment schedule class itself that sends a message to the receptionist when the appointment hasn't been found and the whole process would start again. In general, all the actions of an appointment registration are taken by the receptionist and the patient acts as an external person that only delivers and asks for information.

Looking to prescriptions, it will be the doctor itself that uses the app and he also needs a patient instance to start a prescription request. After getting the personal data from the patient, the doctor can see all the previous prescriptions of the patient and can decide whether he wants to hand over a new one. To be clear, the doctor does not itself maintain a new prescription into the system (for example by adding it into the list) but rather uses the app to look for previous prescription by patient as an information tool. The maintenance of the prescription data file itself will be handled externally. The same is true for the health professional metadata. The only data structure that is really dynamic in this system is the appointment schedule which will fully maintained by the receptionist.

In general, logic is included for:

- authorization to appointments and prescription requests (included as a method in the receptionist as well as in the doc class).
- availabilities of doctor's on a long-term (one doctor can only have 500 patients at any time) and a short-term basis (when is the next available data that fits both, patient and doctor).
- No test for differentiation between lower case and capital case letters because all inputs are directly transformed to lower case letters. The same is true for specific registration formats used by the database (csv file). If there are specifics, then the app handles the transformation (for example adding an underscore to combine strings).

Additionally, the program has already incorporated the use of several csv files (patient, health_pro, appointment schedule, prescription) and doesn't ask the user every time which files he wants to use (i.e. providing file names). The reason for this is that surgery employees probably don't have the skills to handle with issues if there would be an error while loading the csv files. It is therefore important, to handle the app as simple as possible. Thus, the files currently incorporated represent the surgery of "testdata1" and they had to change when the surgery itself would change.   

Furthermore, the code doesn't use class methods which allow for loading and writing into a csv file but rather uses these functions outside of the scope of a class (take a look into **functions.py**). Because of the reason that these (global) functions/methods are not a method within every class, this leads to less developer time and less space in the code (= only written once and not repeatedly for each class).

Looking to the testing strategy, it is worth mentioning that there are three different testdata sets (now there is an input request that asks for file names). All csv files ending with "testdata1" are created by the developer itself whereas files ending with "testdata2" or "testdata3" are artificially created datasets and therefore incorporate a lot more entries. The artificially created data files account for necessary connection between files and if interested, one can take a look into **datacreation.py** to see the construction code. The only file that is a purely static one is "health_pro.csv" which represents the list of health professional of a sample surgery. For testing itself, one can take a look into **testing.ipynb** which runs 5 checkpoints. The different checkpoints handle different appointment requests and therefore the correct use of the find_appoint method (test 1 - test 3), the correct check for authorization in handling different requests (test 4) and finally whether the prescription request correctly searches for queries (test 5). For this, the unittest library of python is used which allow for running different tests and getting an output at the end that indicates how many of these tests have successfully been run and how many not. It is important to note, that for test 4, the user has to provide the program with some inputs. Hence, writing into the command line the information of one employee correctly should lead to a successful run.

# Commentary

The starting point of the code implementation was to define the classes. Because software development often doesn't follow a static structure (waterfall model for example) of steps, I also started to write the main program while I wasn't still finished with the class building process. At the beginning of the process of combining both, class implementation and main, I was still struggling with the question what should be static data and what should be dynamic data. The reason for this lack of clarity was related to a lack of understanding of the classes. Because methods (functions inside of classes) represent the responsibilities of classes, it became clear after some time that it is the receptionist only who should handle appointment requests and a doctor should handle prescription requests. Additionally, only the receptionist class should maintain an appointment list (appointment schedule) whereas the doctor should use the prescription class only for looking into a static list of previously issued prescriptions that helps him to decide if a repetition for a particular patient is still useful. Following this understanding, I could understand why the appointment schedule class only uses a list within the class itself that directly gathers the information provided by the attributes. To be clear, the program also works for example with a health professional list but it will not be maintained by one of the classes itself. A similar reasoning is true for the patient file but with a slight difference. Here, patients will be asked whether they are new or existing patients. But after answering this question, it is the application logic that handles further steps such as adding a new patient to the csv file or do nothing when the patient said that he is an existing patient. To see the difference to an appointment, for a patient there is no class responsible for adding or removing a patient. This is not true for an appointment. A receptionist has to decide whether he wants to "make" or "cancel" an appointment. Hence, in thinking about responsibilities (or methods) of classes, I found a way how my application has to look like.

The second step was then to bring in all the details which are represented by the class diagram. For example, that a doctor should have at most 500 patients at any time. For this step, I decided to count the number of patients per doctor while looping over all doctors and all patients (see method find_a_doc in the receptionist class). A second detail was certainly to implement a consistent logic to find an available date for a patient which is related to a specific doctor. For reason of simplicity, I used the datetime library (Python Software Foundation, 03/2022) which helps to work with a real date and to transform this into seconds so that simple arithmetic operations are possible (for example adding 1800 seconds instead of 00:30 minutes).

While still improving step 1 (system implementation) and step 2 (eye for detail), I already started the testing phase. My main focus here was on the correct use of the find_available_appointment function as well as the correct use of the authorization restrictions. For the former, I rapidly found three test which handle corner cases (a blocked date (1), a blocked date and the next available appointment is after the lunch break (2) and finally a blocked date and the next available date is the next day (3)). For the latter, I used tests which include the idea to provide information in using the command line. So, simply answering the first few questions in providing the input by the command line can already testify whether the coded logic works accurately or not.

# Reference List

Python Software Foundation (Latest update 03/22) 3.8.13 Documentation â€“ Objets DateTime. Available from: https://docs.python.org/fr/3.8/c-api/datetime.html [Accessed 29 April 2022]



